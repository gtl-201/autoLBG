<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sao Ch√©p N·ªôi Dung Trang T√≠nh</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/exceljs/4.3.0/exceljs.min.js"></script>
    <link rel="stylesheet" href="tkbStyles.css">
</head>
<body>
    <div class="container">
        <h1>TH·ªúI KHO√Å BI·ªÇU T·ª∞ ƒê·ªòNG</h1>
        
        <form id="excelForm">
            <div class="form-group">
                <label for="inputFile">üìÅ Ch·ªçn file Excel (.xlsx):</label>
                <div class="file-input-wrapper">
                    <input type="file" id="inputFile" class="file-input" accept=".xlsx,.xls" required>
                    <label for="inputFile" class="file-input-label">
                        <span class="icon">üìÅ</span>
                        Ch·ªçn file Excel
                    </label>
                </div>
                <div class="file-name" id="inputFileName">Ch∆∞a ch·ªçn file</div>
            </div>

            <div class="form-group">
                <label for="rangeSelect">üìä Ch·ªçn v√πng √¥ c·∫ßn sao ch√©p:</label>
                <select id="rangeSelect" class="range-select" required>
                    <option value="D4:E63">TKB cho L·ªãch B√°o Gi·∫£ng</option>
                    <option value="C6:M51">TKB cho S·ªï ƒê·∫ßu B√†i</option>
                </select>
            </div>

            <div class="form-group">
                <label for="outputName">üíæ T√™n file xu·∫•t ra:</label>
                <input type="text" id="outputName" placeholder="Nh·∫≠p t√™n file (kh√¥ng c·∫ßn ƒëu√¥i .xlsx)" value="" required>
            </div>

            <div class="form-group">
                <button type="submit" class="submit-btn" id="submitBtn">
                    <span class="icon">üöÄ</span>
                    X·ª≠ L√Ω v√† T·∫£i File
                </button>
            </div>
        </form>

        <div class="progress-bar" id="progressBar">
            <div class="progress-fill" id="progressFill"></div>
        </div>

        <div class="status" id="status"></div>
    </div>



    <script>
        // X·ª≠ l√Ω hi·ªÉn th·ªã t√™n file
        document.getElementById('inputFile').addEventListener('change', function(e) {
            const fileName = e.target.files[0] ? e.target.files[0].name : 'Ch∆∞a ch·ªçn file';
            document.getElementById('inputFileName').textContent = fileName;
        });

        // X·ª≠ l√Ω form submit
        document.getElementById('excelForm').addEventListener('submit', async function(e) {
            e.preventDefault();
            
            const inputFile = document.getElementById('inputFile').files[0];
            const outputName = document.getElementById('outputName').value.trim();
            const selectedRange = document.getElementById('rangeSelect').value;
            
            if (!inputFile || !outputName) {
                showStatus('Vui l√≤ng ch·ªçn file v√† nh·∫≠p t√™n file xu·∫•t ra!', 'error');
                return;
            }

            try {
                showStatus('ƒêang x·ª≠ l√Ω file...', 'processing');
                showProgress(0);
                
                // ƒê·ªçc file Excel
                const workbook = await readExcelFile(inputFile);
                showProgress(30);
                
                // Ki·ªÉm tra s·ªë l∆∞·ª£ng trang t√≠nh
                if (workbook.worksheets.length < 3) {
                    throw new Error('File ph·∫£i c√≥ √≠t nh·∫•t 3 trang t√≠nh');
                }
                
                // Sao ch√©p n·ªôi dung v·ªõi v√πng ƒë√£ ch·ªçn
                await copySheetContent(workbook, selectedRange);
                showProgress(80);
                
                // T·∫°o v√† t·∫£i file
                await downloadExcelFile(workbook, outputName);
                showProgress(100);
                
                showStatus('‚úÖ X·ª≠ l√Ω ho√†n th√†nh! File ƒë√£ ƒë∆∞·ª£c t·∫£i xu·ªëng.', 'success');
                
            } catch (error) {
                console.error('L·ªói:', error);
                showStatus('‚ùå C√≥ l·ªói x·∫£y ra: ' + error.message, 'error');
            }
        });

        function showStatus(message, type) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = `status ${type}`;
            status.style.display = 'block';
            
            if (type === 'processing') {
                document.getElementById('progressBar').style.display = 'block';
            } else {
                setTimeout(() => {
                    document.getElementById('progressBar').style.display = 'none';
                }, 1000);
            }
        }

        function showProgress(percent) {
            document.getElementById('progressFill').style.width = percent + '%';
        }

        // ƒê·ªçc file Excel v·ªõi ExcelJS
        async function readExcelFile(file) {
            const workbook = new ExcelJS.Workbook();
            const arrayBuffer = await file.arrayBuffer();
            await workbook.xlsx.load(arrayBuffer);
            return workbook;
        }

        // Ph√¢n t√≠ch v√πng √¥
        function parseRange(range) {
            const [start, end] = range.split(':');
            
            // Ph√¢n t√≠ch √¥ b·∫Øt ƒë·∫ßu
            const startMatch = start.match(/([A-Z]+)(\d+)/);
            const startCol = startMatch[1];
            const startRow = parseInt(startMatch[2]);
            
            // Ph√¢n t√≠ch √¥ k·∫øt th√∫c
            const endMatch = end.match(/([A-Z]+)(\d+)/);
            const endCol = endMatch[1];
            const endRow = parseInt(endMatch[2]);
            
            return { startCol, startRow, endCol, endRow };
        }

        // Chuy·ªÉn ƒë·ªïi ch·ªØ c√°i c·ªôt th√†nh s·ªë
        function columnToNumber(column) {
            let result = 0;
            for (let i = 0; i < column.length; i++) {
                result = result * 26 + (column.charCodeAt(i) - 64);
            }
            return result;
        }

        // Chuy·ªÉn ƒë·ªïi s·ªë th√†nh ch·ªØ c√°i c·ªôt
        function numberToColumn(num) {
            let result = '';
            while (num > 0) {
                num--; // Adjust for 1-based indexing
                result = String.fromCharCode(65 + (num % 26)) + result;
                num = Math.floor(num / 26);
            }
            return result;
        }

        // Sao ch√©p n·ªôi dung t·ª´ trang t√≠nh ngu·ªìn sang c√°c trang t√≠nh sau
        async function copySheetContent(workbook, selectedRange) {
            const sheets = workbook.worksheets;
            
            // X√°c ƒë·ªãnh sheet ngu·ªìn v√† sheet ƒë√≠ch d·ª±a tr√™n v√πng √¥
            let sourceSheetIndex;
            let minRequiredSheets;
            let targetStartIndex;
            
            if (selectedRange === 'D4:E63') {
                sourceSheetIndex = 2; // Sheet th·ª© 3 (index 2)
                minRequiredSheets = 3; // C·∫ßn √≠t nh·∫•t 3 sheet
                targetStartIndex = 3; // Sao ch√©p t·ª´ sheet th·ª© 4 tr·ªü ƒëi
            } else if (selectedRange === 'C6:M51') {
                sourceSheetIndex = 1; // Sheet th·ª© 2 (index 1)
                minRequiredSheets = 2; // C·∫ßn √≠t nh·∫•t 2 sheet
                targetStartIndex = 2; // Sao ch√©p t·ª´ sheet th·ª© 3 tr·ªü ƒëi
            } else {
                throw new Error('V√πng √¥ kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£');
            }
            
            if (sheets.length < minRequiredSheets) {
                throw new Error(`File ph·∫£i c√≥ √≠t nh·∫•t ${minRequiredSheets} trang t√≠nh`);
            }
            
            // L·∫•y trang t√≠nh ngu·ªìn
            const sourceSheet = sheets[sourceSheetIndex];
            console.log(`Trang t√≠nh ngu·ªìn: ${sourceSheet.name} (sheet th·ª© ${sourceSheetIndex + 1})`);
            console.log(`V√πng sao ch√©p: ${selectedRange}`);
            
            // Ph√¢n t√≠ch v√πng √¥
            const { startCol, startRow, endCol, endRow } = parseRange(selectedRange);
            const startColNum = columnToNumber(startCol);
            const endColNum = columnToNumber(endCol);
            
            // L∆∞u tr·ªØ d·ªØ li·ªáu v√† ƒë·ªãnh d·∫°ng t·ª´ v√πng ƒë√£ ch·ªçn
            const sourceData = [];
            
            // ƒê·ªçc d·ªØ li·ªáu t·ª´ v√πng ƒë√£ ch·ªçn
            for (let row = startRow; row <= endRow; row++) {
                const rowData = {};
                for (let colNum = startColNum; colNum <= endColNum; colNum++) {
                    const colLetter = numberToColumn(colNum);
                    const cellAddress = `${colLetter}${row}`;
                    
                    rowData[colLetter] = {
                        value: sourceSheet.getCell(cellAddress).value,
                        style: Object.assign({}, sourceSheet.getCell(cellAddress).style)
                    };
                }
                sourceData.push(rowData);
            }
            
            console.log(`ƒê√£ ƒë·ªçc ${sourceData.length} d√≤ng t·ª´ trang t√≠nh ngu·ªìn`);
            
            // Sao ch√©p sang c√°c trang t√≠nh ƒë√≠ch
            let copiedSheets = 0;
            for (let i = targetStartIndex; i < sheets.length; i++) {
                const targetSheet = sheets[i];
                console.log(`ƒêang sao ch√©p sang trang t√≠nh: ${targetSheet.name}`);
                
                // D√°n d·ªØ li·ªáu v√†o v√πng t∆∞∆°ng ·ª©ng
                for (let rowIndex = 0; rowIndex < sourceData.length; rowIndex++) {
                    const targetRow = rowIndex + startRow;
                    const rowData = sourceData[rowIndex];
                    
                    // Sao ch√©p t·ª´ng √¥ trong d√≤ng
                    for (let colNum = startColNum; colNum <= endColNum; colNum++) {
                        const colLetter = numberToColumn(colNum);
                        const cellAddress = `${colLetter}${targetRow}`;
                        
                        const targetCell = targetSheet.getCell(cellAddress);
                        targetCell.value = rowData[colLetter].value;
                        targetCell.style = rowData[colLetter].style;
                    }
                }
                
                copiedSheets++;
            }
            
            console.log(`ƒê√£ sao ch√©p th√†nh c√¥ng sang ${copiedSheets} trang t√≠nh`);
            
            // C·∫≠p nh·∫≠t progress
            showProgress(70);
            
            if (copiedSheets === 0) {
                const minSheetsNeeded = targetStartIndex + 1;
                throw new Error(`Kh√¥ng c√≥ trang t√≠nh n√†o ƒë·ªÉ sao ch√©p (c·∫ßn √≠t nh·∫•t ${minSheetsNeeded} trang t√≠nh)`);
            }
        }

        // T·∫°o v√† t·∫£i file Excel
        async function downloadExcelFile(workbook, fileName) {
            const buffer = await workbook.xlsx.writeBuffer();
            const blob = new Blob([buffer], { 
                type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' 
            });
            
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName.endsWith('.xlsx') ? fileName : fileName + '.xlsx';
            a.style.display = 'none';
            
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
    </script>
</body>
</html>